"""Contains sketch classes necessary for generating animations"""
import csv
from skimage import measure
import OpenGL.GL as GL
import numpy as np
import ctypes
import triangle
from util import prep_texture, get_barycentric_coords, point_in_triangle
import halfedge

import scipy.sparse as sp
import scipy.sparse.linalg as spla
import scipy.linalg as la

from PIL import Image

class ARAP():
    """As-rigid-as-possible animations. Uses joint positions as handles for ARAP"""

    class ARAP_Handle:

        def __init__(self, image_coords=None, v_idx=None, bary_coords=None, dim=None, arap_sketch=None):

            color = (255, 0, 0)
            self.dim = dim

            self.arap_sketch = arap_sketch  # needed so we can apply it's model transform to handles for viewing

            self.cx, self.cy = image_coords
            #self.set_world_coords()
            # self.cx, self.cy = v[0], v[1]

            if bary_coords is None:
                assert v_idx is not None
                self.v_idx = [[v_idx, 1.0]]  # [[vertex_idx, weight]]
            else:
                self.v_idx = [
                    [bary_coords[0][0], bary_coords[0][1]],
                    [bary_coords[1][0], bary_coords[1][1]],
                    [bary_coords[2][0], bary_coords[2][1]]
                ]


        def set_handle(self, x, y):
            assert x is not None
            assert y is not None
            self.cx = x
            self.cy = y
            self.widget.set_position(self.cx, self.cy, 0)

        def draw(self, **kwargs):
            pass

    def __init__(self, img: Image, mask: Image, arap_handle_start_locs):

        self.img = img
        self.mask = mask
        self.tex_id = prep_texture(self.img, GL.GL_RGB)

        self.triangle_mesh = None  # dictionary with mesh generated by Triangle from self.mask
        self._generate_mesh()

        self.tex_id = prep_texture(self.img, GL.GL_RGB)  # initialize texture and store texture id

        self.arap_handles = []
        self._prep_arap_handles(arap_handle_start_locs)

        self.indices = self.triangle_mesh['triangles'].flatten()

        self.mesh_vertices = None
        self._buffer_vertices()

        self.show_mesh_edges = True

        self._arap_setup()
        self.arap_solve()

        self.vao = GL.glGenVertexArrays(1)
        self.vbo = GL.glGenBuffers(1)
        self.ebo = GL.glGenBuffers(1)

        GL.glBindVertexArray(self.vao)

        # buffer vertex data
        GL.glBindBuffer(GL.GL_ARRAY_BUFFER, self.vbo)
        GL.glBufferData(GL.GL_ARRAY_BUFFER, self.mesh_vertices, GL.GL_DYNAMIC_DRAW)

        # buffer element index data
        GL.glBindBuffer(GL.GL_ELEMENT_ARRAY_BUFFER, self.ebo)
        GL.glBufferData(GL.GL_ELEMENT_ARRAY_BUFFER, self.indices, GL.GL_STATIC_DRAW)

        # position attributes
        GL.glVertexAttribPointer(0, 2, GL.GL_FLOAT, False, 4 * self.mesh_vertices.shape[1], None)
        GL.glEnableVertexAttribArray(0)

        # texture attributes
        GL.glVertexAttribPointer(1, 2, GL.GL_FLOAT, False, 4 * self.mesh_vertices.shape[1], ctypes.c_void_p(4 * 3))
        GL.glEnableVertexAttribArray(1)

        GL.glBindBuffer(GL.GL_ARRAY_BUFFER, 0)
        GL.glBindVertexArray(0)

    def toggle_show_mesh_edges(self):
        self.show_mesh_edges = not self.show_mesh_edges
    def move_handle(self, offset):
        self.arap_handles[0].cx += offset[0]
        self.arap_handles[0].cy += offset[1]

    def draw(self, **kwargs):


        GL.glBindBuffer(GL.GL_ARRAY_BUFFER, self.vbo)  # buffer vertex data
        GL.glBufferData(GL.GL_ARRAY_BUFFER, self.mesh_vertices, GL.GL_DYNAMIC_DRAW)
        GL.glBindBuffer(GL.GL_ARRAY_BUFFER, 0)

        GL.glBindVertexArray(self.vao)

        GL.glActiveTexture(GL.GL_TEXTURE0)
        GL.glBindTexture(GL.GL_TEXTURE_2D, self.tex_id)

        # render the sketch texture
        GL.glPolygonMode(GL.GL_FRONT_AND_BACK, GL.GL_FILL)
        GL.glUseProgram(kwargs['shader_ids']['texture_shader'])

        GL.glDrawElements(GL.GL_TRIANGLES, self.indices.shape[0], GL.GL_UNSIGNED_INT, None)

        # render the mesh edges
        if self.show_mesh_edges:
            GL.glUseProgram(kwargs['shader_ids']['color_shader'])

            GL.glPolygonMode(GL.GL_FRONT_AND_BACK, GL.GL_LINE)
            GL.glDrawElements(GL.GL_TRIANGLES, self.indices.shape[0], GL.GL_UNSIGNED_INT, None)
            GL.glPolygonMode(GL.GL_FRONT_AND_BACK, GL.GL_FILL)

        GL.glBindVertexArray(0)

    def _generate_mesh(self):
        mask_np = np.array(self.mask).astype(np.uint8)
        contours = measure.find_contours(mask_np, 0.5)
        assert len(contours) != 0, 'No foreground object contour found within the mask'
        assert len(contours) < 2, 'Multiple contours found within mask. It should contain a single contour'
        _contour = contours[0]

        mesh_contour_step_size = 10 # connect every 5 points along contour to generate mesh. can edit if you need a more fine-detailed mesh
        contour = [(p[1] / self.mask.size[0], p[0] / self.mask.size[1]) for p in _contour[::mesh_contour_step_size]]

        segs = [(idx, (idx + 1) % len(contour)) for idx in range(len(contour))]

        a = dict(vertices=contour, segments=segs, holes=[[-1, -1]])
        self.triangle_mesh = triangle.triangulate(a, 'qpa0.0003')

    def _buffer_vertices(self):
        vert_count = self.triangle_mesh['vertices'].shape[0]
        self.mesh_vertices = np.empty((vert_count, 5), np.float32)
        for idx in range(0, vert_count):
            # since we're not using a camera or projection matrix in this demo,
            # multiply x and y by two and translate to go from image space into unit square
            self.mesh_vertices[idx, 0] = 2 * self.triangle_mesh['vertices'][idx][0] - 1   # x pos
            self.mesh_vertices[idx, 1] = 2 * -self.triangle_mesh['vertices'][idx][1] + 1  # y pos
            self.mesh_vertices[idx, 2] = 0                                                # z pos
            self.mesh_vertices[idx, 3] = self.triangle_mesh['vertices'][idx][0]           # x tex
            self.mesh_vertices[idx, 4] = 1 - self.triangle_mesh['vertices'][idx][1]       # y tex
        return

    def _prep_arap_handles(self, arap_handles_path):
        with open(arap_handles_path, 'r') as f:
            locs = np.array([list(map(int, x)) for x in csv.reader(f)]) / np.array(self.mask.size)

        for idx, (x, y) in enumerate(locs):

            image_coords = [x, y]

            for t in self.triangle_mesh['triangles']:
                v0, v1, v2 = [self.triangle_mesh['vertices'][x] for x in t]
                if point_in_triangle(image_coords, v0, v1, v2):
                    w = get_barycentric_coords(image_coords, v0, v1, v2)
                    handle = self.ARAP_Handle(image_coords=image_coords,
                                              bary_coords=[[t[0], w[0]], [t[1], w[1]], [t[2], w[2]]],
                                              dim=self.img.size,
                                              arap_sketch=self)
                    self.arap_handles.append(handle)
                    break
            else:
                assert False, 'ARAP Handle {} not within a mesh triangle'.format(idx)

    #######################
    # Begin ARAP functions.
    # Based on paper Implementing As-Rigid-As-Possible Shape Manipulation and Surface Flattening
    # http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.173.3112
    # Setup influenced by this repo: https://github.com/tfedor/dzo-arap
    #######################
    def arap_solve(self):

        self.pinPoses = []
        for handle in self.arap_handles:
            self.pinPoses.append((handle.cx, handle.cy))
        self.pinPoses = np.asarray(self.pinPoses)

        b1 = self._buildB1(self.pinPoses, self.w, self.nEdges)
        v1 = spla.spsolve(self.tA1 * self.A1, self.tA1 * b1)

        b2 = self._buildB2(self.heVectors, self.heIndices, self.edges, self.pinPoses, self.w, self.G, v1)
        v2x = spla.spsolve(self.tA2 * self.A2, self.tA2 * b2[:, 0])
        v2y = spla.spsolve(self.tA2 * self.A2, self.tA2 * b2[:, 1])
        v2 = np.vstack((v2x, v2y)).T

        for idx in range(self.mesh_vertices.shape[0]):
            self.mesh_vertices[idx, 0] = 2* v2[idx][0] - 1
            self.mesh_vertices[idx, 1] = 2* - v2[idx][1] + 1

    def _arap_setup(self):
        """ Called once during object construction to generate the reusable parts of the ARAP algorithm"""
        self.xy = self.triangle_mesh['vertices']
        self.halfedges = halfedge.build(self.triangle_mesh['triangles'])
        self.heVectors = np.asarray([self.xy[he.ivertex, :] - self.xy[he.prev().ivertex, :] for he in self.halfedges])
        self.pins = np.array([handle.v_idx for handle in self.arap_handles])

        self.w = 1000.0
        self.nVertices = self.xy.shape[0]
        self.edges, self.heIndices = halfedge.toEdge(self.halfedges)
        self.nEdges = self.edges.shape[0]
        self.A1top, self.G = self._buildA1top(self.heVectors, self.halfedges, self.edges, self.heIndices, self.nVertices)

        self.A1bottom = self._buildA1bottom(self.pins, self.w, self.nVertices)

        self.A1 = sp.vstack((self.A1top, self.A1bottom))
        self.tA1 = self.A1.transpose()

        self.A2top = self._buildA2top(self.edges, self.nVertices)
        self.A2bottom = self._buildA2bottom(self.pins, self.w, self.nVertices)
        self.A2 = sp.vstack((self.A2top, self.A2bottom))
        self.tA2 = self.A2.transpose()

    def _buildA1top(self, heVectors, halfedges, edges, heIndices, nVertices):

        threeVertices2twoEdges = np.asarray(((-1., 0., 1., 0., 0., 0.),
                                             (0., -1., 0., 1., 0., 0.),
                                             (-1., 0., 0., 0., 1., 0.),
                                             (0., -1., 0., 0., 0., 1.)))
        fourVertices2threeEdges = np.asarray(((-1., 0., 1., 0., 0., 0., 0., 0.),
                                              (0., -1., 0., 1., 0., 0., 0., 0.),
                                              (-1., 0., 0., 0., 1., 0., 0., 0.),
                                              (0., -1., 0., 0., 0., 1., 0., 0.),
                                              (-1., 0., 0., 0., 0., 0., 1., 0.),
                                              (0., -1., 0., 0., 0., 0., 0., 1.)))

        Arows, Acols, Adata = [], [], []
        Grows, Gcols, Gdata = [], [], []
        for row in range(0, edges.shape[0]):
            v0, v1 = edges[row, :]
            Arows.append(2 * row)
            Acols.append(2 * v0)
            Adata.append(-1.0)
            Arows.append(2 * row)
            Acols.append(2 * v1)
            Adata.append(1.0)
            Arows.append(2 * row + 1)
            Acols.append(2 * v0 + 1)
            Adata.append(-1.0)
            Arows.append(2 * row + 1)
            Acols.append(2 * v1 + 1)
            Adata.append(1.0)

            vertices = [v0, v1]
            he = halfedges[heIndices[row]]
            edgeVectors = [heVectors[he.iself], ]
            vertices.append(halfedges[he.inext].ivertex)
            edgeVectors.append(-heVectors[he.prev().iself])
            verts2edges = threeVertices2twoEdges
            if he.ipair != -1:
                pair = halfedges[he.ipair]
                vertices.append(halfedges[pair.inext].ivertex)
                edgeVectors.append(heVectors[pair.inext])
                verts2edges = fourVertices2threeEdges
            g = []
            for v in edgeVectors:
                g.extend(((v[0], v[1]), (v[1], -v[0])))
            g = np.asarray(g)
            e = heVectors[heIndices[row], :]
            e = np.asarray(((e[0], e[1]), (e[1], -e[0])))
            g = np.dot(la.inv(np.dot(g.T, g)), g.T)
            g = np.dot(g, verts2edges)
            h = - np.dot(e, g)
            rows, cols = [], []
            for i in range(0, len(vertices)):
                rows.append(2 * row);
                cols.append(2 * vertices[i])
                rows.append(2 * row);
                cols.append(2 * vertices[i] + 1)
            for i in range(0, len(vertices)):
                rows.append(2 * row + 1);
                cols.append(2 * vertices[i])
                rows.append(2 * row + 1);
                cols.append(2 * vertices[i] + 1)

            data = h.flatten()
            Arows.extend(rows)
            Acols.extend(cols)
            Adata.extend(data)
            Grows.extend(rows)
            Gcols.extend(cols)
            Gdata.extend(g.flatten())
        spA1top = sp.csr_matrix((Adata, (Arows, Acols)), shape=(edges.size, nVertices * 2))
        spG = sp.csr_matrix((Gdata, (Grows, Gcols)), shape=(edges.size, nVertices * 2))
        return spA1top, spG

    def _buildA1bottom(self, pins, w, nVertices):
        Arows, Acols, Adata = [], [], []
        for row in range(0, len(pins)):
            for pin in pins[row]:
                pin_idx = pin[0]
                pin_weight = pin[1] * w
                Arows.append(2 * row)
                Acols.append(2 * pin_idx)
                Adata.append(pin_weight)
                Arows.append(2 * row + 1)
                Acols.append(2 * pin_idx + 1)
                Adata.append(pin_weight)
        spA1bottom = sp.csr_matrix((Adata, (Arows, Acols)), shape=(pins.shape[0] * 2, nVertices * 2))
        return spA1bottom

    def _buildB1(self, pinPositions, w, nEdges):
        brows = range(nEdges * 2, nEdges * 2 + pinPositions.size)
        bcols = [0 for i in range(0, len(brows))]
        bdata = (w * pinPositions).flatten()
        bshape = (nEdges * 2 + pinPositions.size, 1)
        b1 = sp.csr_matrix((bdata, (brows, bcols)), shape=bshape).tolil()
        return b1

    def _buildA2top(self, edges, nVertices):
        Arow, Acol, Adata = [], [], []
        for row in range(0, edges.shape[0]):
            v0, v1 = edges[row, :]
            Arow.append(row)
            Acol.append(v0)
            Adata.append(-1)
            Arow.append(row)
            Acol.append(v1)
            Adata.append(1)
        shape = (edges.shape[0], nVertices)
        spA2top = sp.csr_matrix((Adata, (Arow, Acol)), shape=shape)
        return spA2top

    def _buildA2bottom(self, pins, w, nVertices):
        Arow, Acol, Adata = [], [], []
        for row in range(0, pins.shape[0]):
            for pin in pins[row]:
                pin_idx = pin[0]
                pin_weight = pin[1] * w
                Arow.append(row)
                Acol.append(pin_idx)
                Adata.append(pin_weight)
        shape = (pins.shape[0], nVertices)
        spA2bottom = sp.csr_matrix((Adata, (Arow, Acol)), shape=shape)
        return spA2bottom

    def _buildB2(self, heVectors, heIndices, edges, pinPoses, w, G, v1):
        T1 = G * v1
        b2 = []
        for row in range(0, edges.shape[0]):
            e0 = heVectors[heIndices[row], :]
            c = T1[2 * row]
            s = T1[2 * row + 1]
            rScale = 1.0 / np.sqrt(c * c + s * s)
            c *= rScale
            s *= rScale
            T2 = np.asarray(((c, s), (-s, c)))
            e1 = np.dot(T2, e0)
            b2.extend(e1)
        for row in range(0, pinPoses.shape[0]):
            pinPos = pinPoses[row, :]
            b2.extend(w * pinPos)
        b2 = np.asarray(b2).reshape(-1, 2)
        return b2
    #######################
    # End ARAP functions
    #######################
